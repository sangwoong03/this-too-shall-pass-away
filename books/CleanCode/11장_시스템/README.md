# 11장. 시스템

> 도시는 설계할 때부터 많은 요소가 포함된다. 잘 돌아가는 도시는 수도, 전력, 교통 등의 각 분야의 관리 부서가 원활하게 제 역할을 하고 있을 것이다.
> 이처럼 도시가 잘 돌아가는 이유는 적절한 추상화와 모듈화가 잘 되어 있기 때문이다.
> 소프트웨어도 마찬가지다. 높은 추상화 수준을 유지하고 깨끗한 시스템을 유지하는 것이 중요하다.

`Clean Code`에서는 소프트웨어의 시스템을 도시 설계 시스템이나 건축 설계예 빗대어 설명을 많이 하고 있습니다.  
도시를 설계할 때 각각의 시스템이 `모듈화`가 잘되어있다는 것을 그 근거로 설명하고 있습니다.

관심사를 분리하여 깨끗하고 유지보수 하기 쉬운 소프트웨어 시스템 설계 방식에 대해 아래와 같이 설명합니다.

## 시스템 제작과 시스템 사용 분리하는 방법

생성하는 로직과 사용하는 로직을 분리하면 모듈화 수준을 높일 수 있다고 설명합니다.

```javascript
let app
const getInstance = async () => {
  // 생성하는 로직
  if ( app === null ) {
    app = new App()
  }
  // 사용하는 로직
  return app
}
```

위 코드는 `Lazy Initialization(초기화 지연)` 혹은 `Lazy Evaluation(계산 지연)` 기법으로 부하를 줄일 수 있다는 장점이 있습니다.

하지만 `getInstance` 함수가 `new App()`에 의존하고 있으며, 책임이 2개이기 때문에 테스트 하기 어렵습니다.
- App 클래스를 mocking 해야한다.
- app이 null인 경우도 테스트를 해야한다.

### ✔️ `main`을 분리하라.

- 생성과 사용을 분리하는 가장 간단한 방법으로는 main으로 모든 생성 로직을 옮기는 것이라 설명합니다.
- main에서 시스템에 필요한 객체를 생성합니다.
- 이후 생성된 객체를 애플리케이션에 전달하는 방식입니다.

### ✔️ 팩토리

객체의 생성 시기를 애플리케이션에서 결정할 때가 있을 텐데 그 때는 main에서 완성된 객체를 던지는 것이 아닌, 팩토리 함수를 통해 객체를 생성하는 방법을 설명하고 있습니다.

### ✔️ 의존성 주입 (DI, Dependnecy Injection)

생성과 사용을 분리하는 가장 강력한 메커니즘으로 설명합니다. 의존성 주입은 제어 역전 기법을 의존성 관리에 적용한 것입니다.
- 제어 역전을 통해 의존하고 있는 객체에 대한 책임만 생기므로 단일 책임 원칙을 지킬 수 있게 됩니다.
- 즉, 모듈 간의 의존성읠 최소화하고 명확하게 관리하는 것의 중요성을 강조합니다.

## 확장

> 처음부터 완벽한 도시가 없듯 처음부터 완벽한 소프트웨어는 없을 것입니다.

사용자에게 맞는 시스템을 설계하고 구현하면서 필요에 따라 시스템을 조정하고 확장하면 된다고 말합니다.  
그 기반이 되는 것은 물론 TDD나 리팩토링, 깨끗한 코드 기반의 유지보수성이 좋은 코드입니다.

### 횡단 관심사

`횡단 관심사(Cross-cutting Concerns)`는 소프트웨어 개발에서 여러 부분에서 발생하는 공통 문제나 작업을 가리킵니다. 이러한 관심사는 주요 비즈니스 로직과는 관련이 없지만 전체 시스템의 동작과 품질에 영향을 미칠 수 있습니다. 예를 들어, 로깅, 보안, 트랜잭션 관리, 에러 처리, 권한 부여, 캐싱 등이 횡단 관심사의 예시입니다.

`Clean Code`에서는 횡단 관심사를 분리하고 모듈화하여 주요 로직과 분리하여 처리하라고 강조합니다. 이렇게 하면 코드가 더 읽기 쉽고 유지보수가 용이해지며, 각 관심사를 독립적으로 테스트할 수 있습니다.

로깅 관련 코드는 주요 로직과 분리하여 로깅 라이브러리를 사용하는 것이 그 예가 되겠습니다.

## 자바 프록시 ... 순수자바AOP프레임워크 ... AspectJ관점

글만 읽는 느낌이라 나중에 다시 읽어보자..

## 그 외

- 단순하면서도 깔끔하게 분리된 아키텍처로 소프트웨어 시스템을 구축하면 그 확장성을 보장할 수 있을 것입니다.
단, 코드 수준과 아키텍처 관심사를 분리하여 테스트 주도 아키텍처 구축이 가능하다면..
- 모듈화와 관심사 분리를 통해 의사 결정 시점을 결정하고 최적화할 수 있습니다.
- 적절히 표준을 활용하면 재사용성과 확장성을 꾀할 수 있을 것입니다.
- 개발자들 사이에서 적절한 추상화 수준의 코드 의도를 표현할 수 있는 도메인 특화 언어를 사용하면 의사소통의 간극을 줄일 수 있는 시스템을 구축할 수 있을 것입니다.


### ✨ 결론

`Clean Code`가 Java의 관점에서 내용을 전달하고 있지만 코드의 예시가 어렵지는 않았습니다. 하지만 이번 챕터는 살짝.. 그냥 글을 읽고 있구나 정도여서 정리하기가 힘들었습니다.

- 시스템은 깔끔한 코드, 깔끔한 테스트 코드처럼 깔끔해야 도메인 논리를 흐리지 않고 품질을 유지할 수 있습니다.
- 시스템이 좋지 않아 기민성이 떨어지면 TDD로 얻는 이점이 상쇄되는 격입니다.
- 실제로 잘 돌아가고 가장 단순한 시스템을 구축해보십시오.가 핵심.

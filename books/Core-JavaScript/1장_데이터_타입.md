# 🚀 1장. 데이터 타입

> 1장에서는 데이터 타입을 구분하는 방법을 데이터의 선언과 할당. 실행되는 동작 원리에 따라 설명합니다. <br> 추가로 자바스크립트의 메모리 구조, 가비지 컬렉터의 개념과 동작 원리, 객체 복사에 대한 이해를 학습해보고자 합니다. <br> 전반적인 내용은 코어자바스크립트 1장을 참조하였고, 추가 학습 내용에 대해서는 참조 링크를 확인해주세요.<br> <br> 해당 포스팅에서는 `const`, `let`를 사용합니다. 코어자바스크립트에서는 JavaScript언어가 동작하는 원리를 설명하기 위해 var 키워드를 사용한다는 점을 참고해주세요.

<br>

## 📍1-1 데이터 타입의 종류

데이터 타입을 기본형과 참조형으로 나눌 수 있는 주요 차이점은 다음과 같습니다:

1. 할당 방식

   - 기본형 데이터는 값 자체가 변수에 직접 할당됩니다.
   - 참조형 데이터는 값의 메모리 주소가 할당됩니다.

2. 복사 방식

   - 기본형 데이터는 값이 복사됩니다.
   - 참조형 데이터는 메모리 주소가 복사됩니다. 참조형 데이터가 변경되면 연결된 모든 변수에 영향을 줄 수 있습니다.

3. 메모리 관리

   - 기본형 데이터는 고정된 크기를 차지하기 떄문에 메모리 관리가 비교적 용이합니다.
   - 참조형 데이터는 동적으로 크기가 조정되므로 메모리 관리가 복잡할 수 있습니다.

### ✔️ 기본형 (Primitive Type)

할당이나 연산 시 복제되는 타입으로 기본형 타입은 값이 담긴 메모리 주솟값을 바로 복제하여 사용하며 `불변성`이라는 특징이 있습니다. 기본형 데이터 타입은 데이터를 단순히 저장하는 데 사용됩니다. 이러한 데이터는 메모리에 고정된 크기로 저장되며, 해당 변수에 직접 값을 할당합니다.

기본형 데이터 타입의 종류는 다음과 같습니다:

- `숫자(Number)`: 정수와 부동 소수점 숫자를 포함합니다.
- `문자열(String)`: 텍스트를 나타내는 데 사용됩니다.
- `불리언(Boolean)`: true 또는 false 값을 나타냅니다.
- `null`: 아무런 값도 없음을 나타냅니다.
- `undefined`: 값이 할당되지 않은 상태를 나타냅니다.
- `심볼(Symbol)`: 고유하고 변경 불가능한 값을 나타냅니다.

### ✔️ 참조형 (Reference Type)

할당이나 연산 시 참조되는 데이터 타입으로 값이 담긴 메모리 주솟값들로 이루어진 묶음을 가리키는 메모리 주솟값을 복제하여 사용합니다. 다시 말해 참조형 데이터 타입은 변수에 값이 아닌, 값이 위치한 메모리 주소를 저장합니다. 이러한 데이터 타입은 동적으로 크기와 값이 조정될 수 있기 때문에 `가변성`이라는 특징이 있습니다.

참조형 데이터 타입의 종류는 다음과 같습니다:

- `Object`: 여러 속성을 포함하는 컨테이너입니다.
  - `Array`: 여러 값을 순차적으로 저장하는 리스트입니다.
  - `Function`: 코드 블록을 나타내는 객체입니다
  - `Date`: 특정 날짜와 시간을 나타내는 객체입니다.
  - RegExp
  - Map, WeakMap
  - Set, WeakSet

<br>

## 📍1-2 데이터 타입에 관한 배경지식

### ✔️ 1-2-1 메모리와 데이터

과거에는 메모리 용량이 부족한 경우가 많아 정적 언어를 사용할 때 데이터 타입에 따라 형변환을 해야하는 번거로움까지 있었습니다. 타입에 따른 메모리 관리가 항상 수반되었습니다. 하지만 메모리 용량이 월등히 충분해진 현재 자바스크립트 개발자들은 메모리 관리의 압박에서 자유로룬 개발을 할 수 있게 되었습니다.

여기서 말하는 메모리 관리에 대해 알아보겠습니다.

컴퓨터는 모든 데이터를 0과 1로 처리합니다. 데이터를 비트로 변환하여 메모리 조각에 저장하고, 이 비트가 모여 하나의 메모리 데이터를 형성합니다. 이 때 각 비트는 고유 식별자를 지니며 비트를 검색하는데 사용됩니다.

더 정확하게는 메모리 주솟값을 통해 식별자와 데이터 (바이트 > 비트)를 구분하고 연결한다고 볼 수 있습니다.

### ✔️ 1-2-2 식별자와 변수

앞서 언급한 식별자 (고유 식별자)는 변수명을 가리킵니다. 이 식별자가 가리키는 값은 데이터이며 컴퓨터에서 저장될 때는 바이트 혹은 비트의 대상이 됩니다.

```javascript
const 식별자1 (변수명) = 변수1 (데이터);
let 식별자2 (변수명) = 변수2 (데이터);
```

<br>

## 📍1-3 변수 선언과 데이터 할당

### ✔️ 1-3-1 변수 선언

이번에는 변수를 선언하는 방법에 대해 알아보겠습니다. 기본적인 변수 선언 방식은 다음과 같습니다:

```javascript
const 변수1;
```

여기서 변수 선언을 다르게 표현하면 아래와 같습니다:

- 변할 수 있는 데이터를 만들고 이 데이터의 식발자를 `변수1`로 한다.
- 데이터가 담길 수 있는 공간
- 데이터에 `변수1`이라는 이름을 가진 메모리 공간을 확보한다.

그림으로 보면 다음과 같습니다:

- 메모리 주솟값은 임의로 설정됩니다. 1010이라는 메모리 주솟값에 데이터가 저장된다고 가정해보겠습니다.
- 이 메모리 주솟값에 담기는 데이터는 이름과 값을 지닙니다.
- 메모리 주솟값의 가리키는 데이터의 이름은 `식별자` 변수1입니다.
- 메모리 주솟값의 가리키는 데이터의 값은 변수1에 할당되는 `변수`입니다.

| 주소   | 1001 | ... | 1010                 | 1011 |
| ------ | ---- | --- | -------------------- | ---- |
| 데이터 |      |     | 이름: 변수1 <br> 값: |      |

### 1-3-2 데이터 할당

이번에는 선언된 변수에 데이터 `a`를 할당해보겠습니다:

```javascript
const 변수1 = "a";
```

그림으로 보면 다음과 같습니다:

- 메모리 주솟값은 임의로 설정됩니다. 1010이라는 메모리 주솟값에 데이터가 저장된다고 가정해보겠습니다.
- 이 메모리 주솟값에 담기는 데이터는 이름과 값을 지닙니다.
- 메모리 주솟값의 가리키는 데이터의 이름은 `식별자` 변수1입니다.
- 메모리 주솟값의 가리키는 데이터의 값은 변수1에 할당되는 `변수`입니다. 선언 단계에서는 값이 없는 상태입니다.
- 값 'a'를 가리키는 메모리 주소가 새로 할당됩니다. 이 메모리 주소가 5010이라고 가정해보겠습니다.
- 식별자 변수1에 값이 a로 할당되었기 때문에 a의 메모리 주소를 참조하도록 값이 @5010 등으로 생성됩니다.

| 주소   | 1001  | ...   | 1010                       | 1011  |
| ------ | ----- | ----- | -------------------------- | ----- |
| 데이터 |       |       | 이름: 변수1 <br> 값: @5010 |       |
| 주소   | 5001  | ...   | 5010                       | 5011  |
| -----  | ----- | ----- | -----                      | ----- |
| 데이터 |       |       | 'a'                        |       |

값에 a를 바로 대입하면 되지 않을까? 하는 의문이 생길 수도 있습니다. 하지만 아래처럼 코드를 작성하는 상황이 있을 텐데요.컴퓨터 연산을 빠르게 하기 위함입니다.

```javascript
const 변수1 = "a";
const 변수2 = "a";
const 변수3 = "a";
```

만약 숫자형 데이터인 5라는 값을 직접 변수 공간에 할당한다고 가정해봅시다.  
500개의 별도의 변수에 값을 대입하여 생성한다면 4000 (500 _ 8)바이트를 사용하게 될 것입니다.  
하지만 하나의 공간에 5라는 값을 저장하고 해당 주소를 참조한다면 1008 (500 _ 2 + 8) 바이트만 이용하면 됩니다.

메모리 참조 주소를 사용한다고 해서 메모리 소모가 완벽하게 없다는 것을 의미하지는 않습니다. 그럼에도 데이터를 직접 저장하는 방식은 컴퓨터의 처리 연산이 많아지기 때문에 변수 영역과 데이터 영역을 분리하여 중복된 데이터를 효과적으로 처리할 수 있습니다.

> 자바스크립트 메모리 구조를 참고하자.

<br>

## 📍1-4 기본형 데이터와 참조형 데이터

변수와 상수를 구분하는 성질은 `변경 가능성`입니다. 이를 구분 지을 수 있는 기준은 변수 영역의 메모리입니다. 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당 가능성 여부에 따라 달라집니다.

반면 불변성 여부를 구분할 때의 대상은 데이터 영역의 메모리입니다.

### ✔️ 1-4-1 불변값

불변값은 기본형 데이터를 가리키며, 숫자, 문자열, boolean, null, undefined, Symbol가 그 대상입니다.

아래 코드를 먼저 보겠습니다:

```javascript
let 변수1 = "a";
변수1 = "b";
변수1 = 123;

console.log(변수1); // 123
```

- 먼저, `변수1`에 'a'라는 값을 할당할 때 메모리 주소 @5001 ('a')을 활용합니다. (가정)
- 이후 `변수1`에 'b'라는 값을 재할당합니다. 이 땐 메모리 주소 @5002 ('b')를 활용합니다.
- 또 다시 `변수1`에 123라는 값을 재할당합니다. 이 땐 메모리 주소 @5003 (123)를 활용합니다.

여기서 중요한 부분은 한번 만든 데이터 영역에 대한 값들은 변하지 않으며, 한번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 않는다는 특징이 있습니다.

### ✔️ 1-4-1 가변값

참조형 데이터는 가변값인 경우가 있지만 무조건 가변값이 아닌 경우도 있습니다. 우선 참조형 데이터가 선언되고 할당되는 과정에 대해 알아보겠습니다.

- 객체의 프로퍼티들이 모두 기본형 데이터 (불변값)인 경우:

객체의 프로퍼티가 모두 기본형 데이터인 경우에는 아래와 같은 결과를 보입니다.

```javascript
const 객체 = {
  num: 123,
  str: "abc",
};
객체.num = 456;

console.log(객체);
// {
//   num: 456.
//   str: 'abc'
// }
```

순서를 보면 다음과 같습니다:

1. `객체`라는 이름과 객체의 프로퍼티 그룹에 대한 데이터 영역 주솟값을 참조값으로 갖고 있는 변수 영역이 생성됩니다.
2. 객체의 프로퍼티 그룹에 대한 데이터 영역 주솟값은 데이터 영역으로, 각각의 프로퍼티에 대한 메모리 주솟값 범위를 참조합니다.
3. 각각의 프로퍼티의 이름에는 키 (key)와 값 (value)의 메모리 주솟값을 참조하는 값으로 구성됩니다.
4. 이 때 값 (value)는 또 다른 데이터 영역에서 별도의 메모리 주솟값을 갖는 데이터 영역으로 구성됩니다.
5. `456이라는 값 (value)는 불변값으로 기존의 123 데이터가 변경되는 것이 아니라 새로 생성되며 3번에서 참조하고 있는 메모리 주솟값만 변경됩니다.`

- 객체의 프로퍼티 중 하나 이상이 참조형 데이터 (가변값, 중첩 객체)인 경우:

객체의 프로퍼티 중 하나 이상이 참조형 데이터, 즉 중첩 객체의 형태인 경우에는 아래와 같은 결과를 보입니다:

```javascript
const 객체 = {
  str: "abc",
  nestedObj: {
    str: "abcdef",
    num: 123,
  },
};

객체.nestedObj = "nestedObject";

console.log(객체);
// {
//   str: 'abc',
//   nestedObj = 'nestedObject'
// }
```

순서를 보면 다음과 같습니다:

1. `객체`라는 이름과 객체의 프로퍼티 그룹에 대한 데이터 영역 주솟값을 참조값으로 갖고 있는 변수 영역이 생성됩니다.
2. 객체의 프로퍼티 그룹에 대한 데이터 영역 주솟값은 데이터 영역으로, 각각의 프로퍼티에 대한 메모리 주솟값 범위를 참조합니다.
3. 각각의 프로퍼티의 이름에는 키 (key)와 값 (value)의 메모리 주솟값을 참조하는 값으로 구성됩니다.
4. 이 때 값 (value)는 또 다른 데이터 영역에서 별도의 메모리 주솟값을 갖는 데이터 영역으로 구성됩니다.
5. 만약 프로퍼티가 객체 혹은 배열인 경우에 위와 같은 과정을 다시 반복합니다.
6. `nestedObj 식별자가 참조하고 있는 메모리 주솟값을 'nestedObject'라는 값이 할당된 데이터 영역의 메모리 주솟값으로 변경됩니다. 하지만 "객체"가 참조하고 있는 데이터 메모리 주솟값은 변하지 않습니다.`

### ✔️ 1-4-1 변수 복사 비교

변수를 복사하는 과정에서는 기본형과 참조형 데이터 모두 동일한 과정을 거칩니다.

기본형 데이터는 데이터 영역의 메모리 주솟값 하나를 여러 데이터 영역에서 참조할 수 있으며, 참조형 데이터 역시 데이텨 영역의 메모리 주솟값 하나를 여러 데이터 영역에서 참조할 수 있습니다.

코드로 예를 들면 아래와 같습니다:

```javascript
// 1이라는 데이터 메모리 주솟값을 a, b 모두 동일하게 참조
const a = 1;
const b = 1;

// { c: 3, d: 4 } 객체 프로퍼티 그룹 데이터 메모리 주솟값을 object1, object2 모두 동일하게 참조.
const object1 = { c: 3, d: 4 };
const object2 = object1;
```

이렇게 복사 과정은 동일하지만 데이터 할당 과정에서 차이가 발생하기 때문에 변수 복사 이후의 동작에 차이가 발생합니다.

다시 코드를 들여다 보겠습니다:

우선 기본형 데이터를 할당하고 복사하는 경우 변수 b에 a를 복사했지만, b에 또 다른 값을 재할당해도 a의 값은 변하지 않습니다. 그렇기 때문에 a와 b의 일치 연산을 비교했을 때 `false`가 반환됩니다. 값이 다르고 참조 메모리 주솟값도 다르기 때문이죠.

```javascript
// 1이라는 데이터 메모리 주솟값을 a, b 모두 동일하게 참조
const a = 1;
let b = a;
b = 7;

console.log(a); // 1;
console.log(b); // 7;
console.log(a === b); // false
```

하지만 객체의 경우 object2라는 식별자에 oject1에 할당된 객체를 복사하고, object2의 프로퍼티를 추가해도 object1과 동일하다는 결과가 발생합니다.

```javascript
// { c: 3, d: 4 } 객체 프로퍼티 그룹 데이터 메모리 주솟값을 object1, object2 모두 동일하게 참조.
const object1 = { c: 3, d: 4 };
const object2 = object1;
object2.e = 5;

console.log(object1); // { c: 3, d: 4, e: 5 }
console.log(object2); // { c: 3, d: 4, e: 5 }
console.log(object1 === object2); // true
```

이러한 차이가 발생하는 이유는 다음과 같습니다:

- 기본형 데이터는 참조하는 메모리 주솟값 자체가 변경됩니다.
- 참조형 데이터는 객체의 프로퍼티 그룹에 대한 메모리 주솟값을 참조합니다.
- 객체의 프로퍼티가 변경되어도 객체의 프로퍼티 그룹에 대한 메모리 주솟값은 변경되지 않습니다.

만약 새로운 객체를 할당하고 싶다면 아래와 같이 작성할 수 있겠네요!

object1과 object2는 결국 같은 객체의 모습을 띄더라도 9번째 라인에서 object2에 할당되는 객체는 새로운 메모리 주솟값을 지니기 때문에 기존의 object1과 다르다고 평가됩니다.

```javascript
const object1 = { c: 3, d: 4 }; // ---> 메모리 주소가 1001이라고 가정
let object2 = object1; // 메모리 주소: 1001
object2.e = 5;

console.log(object1); // { c: 3, d: 4, e: 5};  ---> 메모리 주소: 1001
console.log(object2); // { c: 3, d: 4, e: 5};  ---> 메모리 주소: 1001
console.log(object1 === object2); // true

object2 = { c: 3, d: 4, e: 5 }; // 메모리 주소가 1002로 다시 할당됨

console.log(object1); // { c: 3, d: 4, e: 5}; // 메모리 주소: 1001
console.log(object2); // { c: 3, d: 4, e: 5}; // 메모리 주소: 1002
console.log(object1 === object2); // false
```

<br>

## 📍1-5 불변 객체

1-4에서 알아보았듯 객체는 객체 자체가 아니라 프로퍼티를 변경할 때 가변적이라는 특징이 있습니다. 하지만 프로그래밍을 하면서 필요에 따라 객체의 원본이 변하지 않아야 하는 경우가 발생합니다. 이럴 땐 불변 객체를 만들면 됩니다.

### ✔️ 얕은 복사

우선 객체의 프로퍼티가 변하면서 원본이 변하는 경우부터 알아보겠습니다. (불변 객체 X)

아래 코드와 같이 object2의 프로퍼티 값을 수정해도 object1의 값이 변경됩니다. 그 이유는 위에서 설명했듯 객체의 프로퍼티 그룹에 대한 메모리 주솟값만을 참조하기 때문입니다. 이를 `얕은 복사`라고 합니다.

```javascript
const object1 = {
  num: 3,
  obj: {
    num: 111,
  },
};

object2.num = 5;
console.log(object1.num === object2.num); // true
console.log(object1);
// {
//   num: 5,
//   obj: {
//     num: 111,
//   }
// }

object2.obj.str = "abc";
console.log(object1 === object2); // true
console.log(object1);
// {
//   num: 3,
//   obj: {
//     num: 111,
//     str: 'abc'
//   }
// }
```

### ✔️ 깊은 복사와 불변 객체 만들기

원본이 변경되는 것을 막기 위해서는 깊은 복사를 사용해야 합니다. 깊은 복사를 이용하는 방법에는 다양한 방법이 있으며 해당 챕터에서는 3가지 방법에 대해 설명합니다.

1. 재귀 함수를 통한 깊은 복사

```javascript
function deepCopy(obj) {
  let result = {};
  if (typeof obj === "object" && obj !== null) {
    for (let prop in obj) {
      result[prop] = deepCopy(obj[prop]);
    }
  } else {
    result = obj;
  }
  return obj;
}
```

2. JSON을 활용한 깊은 복사

```javascript
function deepCopy(obj) {
  return JSON.parse(JSON.stringify(obj));
}
```

3. 라이브러리를 활용한 깊은 복사

- immutable.js, baobab.js, `loadsh` 등 라이브러리 활용

<br>

## 📍1-6 undefined와 null

자바스크립트의 `undefined`와 `null`은 '없음'을 나타내는 값입니다. 하지만 이 둘은 ES6 이후 그 의미와 사용법에 있어 명확한 차이를 보입니다.

### ✔️ undefined

자바스크립트 엔진은 사용자가 어떤 값을 지정할 것이라고 예상되는 상황이지만 실제로 값이 할당되지 않았을 때 undefined를 반환합니다. 아래 내용을 천천히 살펴보겠습니다.

1. 사용자가 undefined 값을 직접 할당하는 경우.

```javascript
const 변수 = undefined;

console.log(변수); // undefined
```

2. 식별자에 대한 변수 (값)을 지정하지 않은 경우.

```javascript
const 변수;

console.log(변수); // undefined
```

3. 객체 내부의 존재하지 않는 프로퍼티에 접근하는 경우

```javascript
const 객체 = {
  프로퍼티1: "값1",
};
console.log(객체.프로퍼티2); // undefined

const 배열 = [];
console.log(배열[2]); // undefined
```

4. return문이 없거나 호출되지 않는 함수를 실행할 경우

```javascript
function 함수() {
  console.log("return문이 없는 함수");
}

함수();
// return문이 없는 함수
// undefined
```

### ✔️ null

let, const는 값을 대입하지 않은 변수에 대해서는 undefined를 할당하지 않은 채로 초기화를 하기 때문에 실제 변수가 평가되기 전까지는 접근할 수 없습니다. 자바스크립트 엔진에서는 자동으로 undefined 값을 반환해주고 있기 때문에 사용자가 직접 undefined를 할당해야 하는 이유에 대해 의문이 생길 수도 있습니다.

바로 이럴 때 null을 사용하는 것이 좋습니다. `비어있음`을 의미하는 값입니다.

자바스크립트 엔진이 null을 평가하는 방법은 다음과 같습니다:

```javascript
const 변수 = null;

console.log(변수); // null

console.log(변수 == undefined); // true
console.log(변수 === undefined); // false
console.log(변수 == null); // true
console.log(변수 === null); // true
console.log(typeof 변수); // 'object'
```

여기서 자바스크립트의 `null`의 타입이 object인 이유는 다음과 같습니다.

> 자바스크립트는 Java의 보조 언어로서 비전문가들을 위해 탄생했기에 초기 Javascript는 Java와 비슷한 문법을 가지고 있어야 한다는 요구사항이 있었습니다. 하지만 Java에서는 "없다"를 나타내는 값이 null 하나뿐입니다. 변수의 정적 타입이 있어서 변수가 객체 타입이면 있어야 할 객체 참조가 없는 것을 나타내고 다른 타입이면 할당된 값이 없는 것으로 의미를 구분할 수 있었습니다.</br> </br> 하지만 자바스크립트는 타입이 없으며 하나의 변수에 객체 참조도 값도 담을 수 있도록 설계되었습니다. 그래서 null이 할당된 값이 없다는 건지 객체 참조가 없다는 건지 구분하기 어려웠습니다. 그래서 null은 원래 객체 참조가 들어 있어야 하는데 참조가 없음을 나타내는 값으로 하고, 그리고 그냥 할당된 값이 없다는 걸 나타내는 값으로 undefined를 만들었다고 합니다.
>
> > 추가! Number() 함수의 인자로 null을 넣으면 0이 반환됩니다. 참조하는 '객체' 값이 없다는 것을 숫자 표현하면 0이 되는 C언어의 포인터를 참고하여 개발되었다고 합니다. 반면 undefined는 객체도 아니고 원시값 자체도 없기 때문에 정수 범위를 벗어나는 값인 -2의 30제곱으로 표현되었고, 자바스크립트에서는 Number() 인자로 undefined를 넣으면 NaN이 반환된다고 합니다.

자바스크립트가 설계된 이유와 배경을 들여다보면 위의 코드 라인 중 가장 마지막 라인인 타입을 확인하는 부분에서 null의 타입이 `object`인 이유를 알 수 있습니다. 이는 자바스크립트의 자체 버그로써 비지니스 로직을 처리할 때 개발자들이 명확히 알고 사용을 해야할 것 같습니다.

<br>

## 📍1-7 정리

### 자바스크립의 타입

- 기본형 vs 참조형

### 변수

- 데이터가 담길 수 있는 공간 (실제 데이터, 변수값)

### 식별자

- 변수의 이름 (변수명)

### 기본형 데이터 할당 과정

1. 변수 선언 시 메모리의 빈 공간에 식별자 저장 후 변수의 값 영역에 undefined 할당.
2. 별도의 공간에 데이터 (기본형 데이터 값)를 저장.
3. 2에서 설정된 공간 주소를 1에서 undefined로 설정된 값 영역에 할당.

### 참조형 데이터 할당 과정

1. 참조형 데이터 내부 프로퍼티들을 한데 모은 데이터 영역 주솟값을 할당합니다.
2. 내부 프로퍼티들을 한데 모은 데이터 영역의 주솟값은, 각각의 프로퍼티를 변수와 데이터 영역으로 하는 메모리 주솟값의 범위를 값으로 가집니다.
3. 각각의 프로퍼티는 프로퍼티의 이름과 값을 지니며, 값은 또 다른 데이터 영역의 주솟값을 참조값으로 구성됩니다.

### 결국은 다 참조한다 (추가)

- 기본형도 데이터 영역의 메모리 주솟값을 참조한다. 참조형 데이터도 참조합니다.
- 직접 값을 사용하지 않는 이유는 메모리 주소를 참조하는 것이 직접 값을 대입하는 것보다 유리하기 때문입니다.

### 가비지 컬렉터 (추가)

- 프로그램에서 더 이상 사용되지 않는 메모리를 자동으로 식별하고 해제하여 프로그램이 메모리를 효율적으로 사용할 수 있도록 도와줍니다.
- 메모리 누수(memory leaks)를 방지하고 프로그램의 성능을 향상시키는데 그 목적이 있습니다.
- 자바스크립트는 개발자 눈에 보이지 않는 곳에서 변수, 함수 등에 사용되는 메모리 관리를 수행합니다.
- 메모리 참조한다. 참조하는 카운팅이 0이면 = 안쓰면 삭제한다.

### 얕은 복사

- 아래 단계의 값 (참조값)만 복사하는 방법입니다.
- 변수가 객체의 참조값을 가리키고 있기 때문에 복사된 변수 역시 객체가 저장된 메모리 공간의 참조 주솟값을 가리킵니다.
- 얕은 복사 후 하나의 객체를 수정하면 서로 다른 두 변수는 똑같은 참조를 가리키고 있기 때문에 기존 객체를 저장한 변수에 영향을 끼칩니다.

### 깊은 복사

- 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법입니다.
- 기본형 데이터는 그대로 복사하면 되지만, 객체의 프로퍼티 중 참조형 데이터는 다시 그 내부의 프로퍼티를 복사해야 합니다.
- 깊은 복사의 방법에는 `재귀함수`, `JSON.parse(JSON.stringify(object))`, 라이브러리 사용 등이 있습니다.

### undefined와 null

- 없음을 나타낸다.
- undefined는 할당이 안된 것.
- null은 비어있는 값이며 참조된 객체 주솟값이 없다는 뜻이기에 object 타입.
- 없음을 의도적으로 표현할 땐 null을 쓰자.

---

### 출처

- https://2ality.com/2013/10/typeof-null.html
- https://ko.javascript.info/garbage-collection
- https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_management

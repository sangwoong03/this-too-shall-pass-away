# 📍 NoSQL

세상에는 방대한 양의 데이터가 존재합니다. 눈에 보이는 것, 보이지 않는 것, 손에 잡히거나 잡히지 않는 모든 사물이 데이터라고 볼 수도 있습니다. 특히 IT 산업이 극도로 발달하면서 인터넷 보급이 많아졌고, 온라인 상에서는 모든 것이 데이터를 주고 받는 일이 많이 발생하고 있습니다.

인터넷 보급에 따라 일반 사람들이 데이터를 많이 주고 받는 서비스인 `소셜 미디어 서비스`가 등장합니다. 이런 소셜 미디어의 특징은 실시간 채팅, 게시글 업로드 등 실시간으로 데이터를 주고 받는 행위가 많다는 것입니다. 사용자들은 더 빠른 채팅과 데이터를 주고 받기를 원하게 됩니다. 즉 이전에는 없던 대용량 트래픽 처리 방법과 빠른 응답 시간에 대한 요구사항이 중요해지게 되죠. 뿐만 아니라 텍스트, 이미지 등 다양하고 정립되지 않는 데이터가 증가하게 되면서 기존의 `RDBMS`로는 해결하기 힘든 요구 사항이 잇따르게 됩니다.

시대의 흐름이 변하면서 `NoSQL`이라는 개념이 등장하게 됩니다. RDBMS를 보완해줄 수 있다고 여겨진 NoSQL은 `No + SQL` 을 가리키기 보다는 `Not Only SQL` 의미에 조금 더 가깝습니다. 즉 SQL을 사용하진 않지만, SQL을 완전히 배제하는 것은 아니라는 것입니다. NoSQL은 RDBMS와는 반대의 성격을 가지고 있습니다. 데이터의 정합성과 무결성을 지키기보단 모든 데이터를 축적하고 한번에 조회한다는 특징이 있습니다.

대표적인 NoSQL의 예시는 다음과 같습니다:

- MongoDB
- Redis
- Amazon DynamoDB
- CouchDB
- neo4j
- HBASE

<br>

## 특징

모든 RDBMS 서비스가 동일한 성능과 기술을 갖고 있지 않은 것처럼 NoSQL 데이터베이스 서비스 역시 각각 다른 특징과 성능을 지니고 있습니다. 개발팀에서 사용하고 있는 MongoDB 데이터베이스의 자세한 특징을 알아보기에 앞서, NoSQL 데이터베이스가 지닌 일반적인 특징에 대해 먼저 알아보겠습니다.

- `자유로운 스키마 변경`을 통해 애플리케이션 변경에 신속하게 대응할 수 있습니다.
- `중복 (Denormalization)`을 허용하기 때문에 scale-out이 가능합니다.
- 한번에 읽을 수 있는 데이터는 `한번에 저장 (Aggregation)`하여 데이터 처리 성능을 높일 수 있습니다.

### ✔️ 자유로운 스키마 변경

기존의 RDBMS는 테이블을 생성하고, 행과 열에 타입과 속성을 지정해주어야 했습니다. 유저의 정보를 담는 `users` 테이블을 생성할 때에는 name과 email 컬럼에 담기는 값이 어떤 타입이며, 다른 테이블을 참조하는 경우 참조하는 해당 테이블에 대한 정보까지 지정을 해주어야합니다.

- RDBMS 스키마 생성

```sql
CREATE TABLE users (
  id INT PRIMARY_KEY AUTO_INCREMENT,
  name VARCHAR(20) NOT_NULL,
  email VARCHAR(20) NOT_NULL
);
```

- RDBMS 스키마 수정

만약 users 테이블에 `age` COLUMN을 추가하려는 경우, 다시 테이블 스키마를 변경 해주어야 하며 기존 데이터에 대해 age 기본 값까지 설정을 해주어야 하는 불편함이 발생합니다.

```sql
ALTER TABLE users ADD COLUMN age INT NOT NULL;
```

- NoSQL 컬렉션 생성 (MongoDB 기준)

하지만, NoSQL에서는 RDBMS의 테이블에 해당하는 데이터 셋을 구축할 때 아래처럼 생성하면 됩니다. 물론 데이터의 타입을 미리 지정하고, 참조하는 컬렉션의 정보를 미리 지정해줄 수도 있습니다. 다음은 MongoDB의 문법을 예로 들면 컬렉션 (Collection)을 생성하는 문법입니다:

```bash
db.createCollection('users')
```

- NoSQL 도큐먼트 추가 및 스키마 수정 (MongoDB 기준)

{ Key: value } 형식의 데이터셋을 지니는 MongoDB는 데이터를 추가하고 스키마를 변경하는 방법도 정말 간단합니다. 원하는 데이터 값 (value)과 그 값에 어울리는 키 (key)를 한쌍으로 지정해주면 됩니다.

```bash
# name과 email만 추가하는 경우
db.users.insertOne({
  name: 'test',
  email: 'test@email.com'
})

# name과 email을 추가하다가 age를 추가해야 하는 경우
db.users.insertOne({
  name: 'test1',
  email: 'test1@email.com',
  age: 15
})
```

### ✔️ 중복 데이터를 허용한다. - Denormalization

모든 특징을 설명하는 데 있어 가장 선두에 오는 문장이 될 것 같습니다.

```sql
NoSQL 데이터베이스는 데이터의 중복을 허용합니다.
```

RDBMS가 더 익숙하다면 해당 섹션을 처음 보았을 때 이해가 잘 안될 수도 있습니다. 제 1정규화, 2정규화 등 데이터의 중복을 제거하는 과정이 이미 모델링 과정에 포함되어 있기 때문입니다.

```bash
데이터는 무결성을 지켜야하며 ... 정규화를 위해 ... 어쩌구 저쩌구...
```

하지만 NoSQL의 `중복 데이터를 허용` 하는 특징은 RDBMS의 정규화를 통해 데이터를 관리했을 때와는 다른 이점을 가져올 수 있습니다:

- 성능 향상: 중복된 데이터는 컬렉션 어디서든 존재하기 때문에 하나의 컬렉션만 조회하면 됩니다.
- 확장 가능: 데이터 중복이 허용되기 때문에 여러 서버에 데이터를 분산시킬 수 있습니다.
- 비용 절감: 중복된 데이터 연산을 처리하기 위해 최소한의 쿼리를 사용하여 개발할 수 있습니다.

하지만, 데이터의 중복을 허용하는 것은 마냥 장점만 있는 것은 아닙니다.

- 데이터의 양이 많으면 오히려 쿼리 성능이 낮이질 수 있습니다. 단순 업데이트의 경우 오히려 성능이 저하될 수 있습니다.
- 데이터의 중복을 허용함으로써 애플리케이션 레벨의 책임이 높아질 수 있습니다. 성능 향상을 위해 DBA와 개발자 간의 책임을 떠 넘겨서는 안되겠죠.
- 금융 시스템, 결제 시스템 등 데이터의 일관성이 중요한 경우 사용에 주의해야 합니다. 중복된 데이터 중 일부가 업데이트 되지 않아 일관성을 해칠 가능성이 있습니다.

### ✔️ 한번에 읽을 수 있는 데이터는 한번에 저장한다. - Aggregation

NoSQL의 또 다른 특징은 중복 데이터를 허용하기 때문에 한번에 읽을 수 있는 데이터를 한번에 저장할 수 있다는 것입니다. 다시 RDBMS의 모델링 방식과 비교를 해보겠습니다.

- RDBMS에서 유저와 게시글 정보는 다음과 같이 표현됩니다. | id | name | email | | --- | ----- | --------------- | | 1 | user1 | user1@email.com | | 2 | user2 | user2@email.com | | id | title | user_id | | --- | --------------- | ------- | | 1 | user1의 게시글1 | 1 | | 2 | user1의 게시글2 | 1 | 이처럼 `user1` 이 작성한 게시글을 데이터베이스에 저장하기 위해 정규화 과정을 거치게 되고, 게시글의 정보만 따로 관리하는 `posts` 을 생성하여 user의 id 값을 참조하도록 스키마를 작성하게 될 것입니다.
- NoSQL에서 데이터를 한번에 저장하기. 데이터의 중복이 크게 중요하지 않은 NoSQL 데이터베이스 관점에서는 테이블을 참조하는 행위가 불필요합니다. MongoDB를 예로 들면 유저와 게시글의 관계를 아래 JSON 형식으로 저장하고 관리할 수 있습니다.
  ```json
  {
    "_id": 1,
    "name": "user1",
    "email": "user1@email.com",
    "posts": [
      {
        "_id": 1,
        "title": "user1의 게시글1"
      },
      {
        "_id": 2,
        "title": "user1의 게시글2"
      }
    ]
  }
  ```
  `user1` 이라는 사람이 게시글을 쓸 때마다 posts 컬렉션에 게시글 정보가 추가되지 않고 users 컬렉션의 `posts` key에 데이터를 저장합니다.

이렇게 연관되어 있는 데이터를 한 컬렉션 (테이블)에 저장하면서 더 적은 연산으로 데이터 처리를 할 수 있다는 장점이 있습니다. 하지만, 데이터의 크기가 크고 많아진다면 특정 연산에서는 성능이 저하될 수 있기 때문에 Aggregation의 특징을 고려하여 모델링을 해야할 것입니다.

<br>

# 📍 MongoDB

MongoDB는 앞서 설명했듯 NoSQL의 대표적인 데이터베이스 서비스입니다. 코딩을 배우는 초보자들도 쉽게 접할 수 있는 MongoDB는 기업에서도 그 활용도가 매우 높습니다. 애플리케이션과 쉽게 연동할 수 있으며, 데이터베이스를 직접 관리하거나 완전 관리형 서비스를 이용할 수 있는 Atlas까지 제공하고 있습니다.

<br>

## 1. 도입 배경

쉽게 개발팀에서는 MongoDB를 도입하여 서비스를 운영하고 있습니다.

RDBMS 역시 서비스를 운영하고 초기 런칭을 위해 좋은 선택지가 될 수 있었습니다. 쉽게 주요 서비스는 고객의 언어 데이터를 하나의 일관성 있는 언어로 다듬어 주는 것입니다. 애플리케이션 도메인을 분석하면서 수십만개에 달하는 고객의 데이터를 빠르게 처리해야 하는 요구사항이 주어졌습니다. 이런 요구 사항을 해결하는데 있어 MongoDB의 아래 이점이 매력적으로 느껴졌습니다.

### ✔️ JSON 기반의 데이터 저장 방식

MongoDB의 두드러진 특징 중 하나는 데이터 저장을 위해 JSON과 유사한 문서를 사용한다는 것입니다. 전통적인 관계형 데이터베이스가 행과 열을 사용하는 것과 달리 MongoDB는 유연한, 스키마가 없는 문서 모델을 채택합니다. 데이터는 BSON(Binary JSON) 형식으로 저장되며 이는 JSON과 유사한 문서의 이진 표현입니다.

HTTP 통신에서 주고 받는 데이터의 형식과 동일하기 때문에 애플리케이션 레벨에서 다루기가 무척 편리한 장점이 있습니다.

### ✔️ 자유로운 스키마

동적 스키마를 허용한다고도 표현할 수 있습니다.

### ✔️ 편리한 사용 및 확장

<br>

## 2. 위기와 극복 과제

RDBMS에 더 익숙했던 개발팀에게 MongoDB를 사용하면서 위기가 찾아왔습니다.

- 트랜잭션 (Transaction)을 쓰는데 처리 속도가 너무 느린 것 같은데?
- 컬렉션의 수와 구조가 RDBMS를 사용할 때와 비슷해질 것 같은데?

다행히 서비스가 더 확장되기 전에 이러한 현상을 발견했는데요. NoSQL에 대해 연구를 해볼 수록 MongoDB를 MongoDB 답게 사용하지 못하고 있다고 진단했습니다. 이를 해결하기 위해 다음 두가지 목표를 설정했습니다.

### ✔️ 데이터 중복을 막지 말자

초기 모델링 과정에서 데이터 중복을 막는 관점으로 모델링을 시작했습니다. 이러한 모델링은 MongoDB 내부의 컬렉션 수가 늘어나는 원인이 되었습니다. 데이터의 중복을 허용할 땐 모든 데이터의 중복을 허용하는 것이 아닌, 자주 바뀌지 않는 주요 데이터의 중복을 허용하는 것을 원칙에 두기로 했습니다.

여기서 `자주 바뀌지 않는` 이라는 기준을 세운 이유는 다음 가설을 근거로 합니다:

- 자주 바뀌지 않는 데이터는 중요한 데이터일 것이다.
- 서버가 확장됨에 따라 자주 바뀌는 데이터가 중복된다면, 오히려 데이터를 관리하기 힘들어질 것이다.

### ✔️ 쿼리의 수를 줄여보자

이 목표를 달성하기 위해서는 중복을 허용하거나 Aggregation을 통해 컬렉션 수를 조정한다면 쿼리의 수는 자동으로 줄어들 것입니다. 이 목표를 달성하기 위해서는 MongoDB에서 제공하는 쿼리 함수에 대해 면밀히 살펴보고 애플리케이션 레벨에서 적재적소에 사용하는 것이 중요할 것입니다. 또한 데이터의 정합성이 중요한 서비스에 대한 심도 깊은 판단을 통해 트랜잭션의 적용 여부를 결정하는 것도 중요합니다.

다만, 쿼리의 수를 무작정 줄인다고 해서 MongoDB가 지니는 이점을 모두 누릴 순 없을 것입니다. 그 이유는 다음과 같습니다:

- 데이터의 무결성과 정합성이 중요한 서비스의 경우 처리 속도 대신 데이터가 안전하게 처리되는 것이 더 중요하다. (e.g., 결제 서비스)
- 다수의 쿼리가 규모가 작은 데이터를 처리하는 속도보다 덩어리가 큰 하나의 데이터를 처리하는 속도가 더 느릴 수도 있을 것이다.

<br>

# 📍 회고

RDBMS와 NoSQL의 장단점을 따져가며 데이터베이스를 선택하고 활용하는 것도 물론 중요합니다. 하지만 데이터베이스가 지닌 특징을 잘 이해하여 도메인과 올바르게 연결할 수 있는 관점을 지닌 개발자가 되어야하지 않을까하는 작은 회고를 해봤습니다.

<br>

## 참고자료

- MongoDB 공식문서
  - [Intro](https://www.mongodb.com/docs/manual/introduction/)
  - [Data Modeling](https://www.mongodb.com/docs/manual/data-modeling/)
- **[NoSQL vs RDBMS](https://www.youtube.com/watch?v=sqVByJ5tbNA)** (youtube)
  - [NoSQL 정보를 찾아볼 수 있는 사이트](https://hostingdata.co.uk/nosql-database)
- [MongoDB 모델링 기법](https://www.youtube.com/watch?v=oUjpMJNtfYE&list=LL&index=4&t=271s) (youtube)
- [Line+가 사내에 MongoDB를 도입한 이유](https://fastcampus.co.kr/story_article_yhs)
